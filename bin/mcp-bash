#!/usr/bin/env bash
# mcp-bash must execute on Bash â‰¥3.2 across macOS/Linux/WSL without edits.
# Core targets MCP protocol version 2025-06-18 and maintains stdout discipline.
# Transport scope is limited to stdio; no alternative transports are supported.

set -euo pipefail

usage() {
	cat <<'EOF'
Usage:
  mcp-bash                 # launch server
  mcp-bash scaffold tool <name>
  mcp-bash scaffold prompt <name>
  mcp-bash scaffold resource <name>
EOF
}

mcp_template_render() {
	local template="$1"
	local output="$2"
	shift 2
	local content
	content="$(cat "${template}")"
	for pair in "$@"; do
		local key="${pair%%=*}"
		local value="${pair#*=}"
		content="${content//${key}/${value}}"
	done
	printf '%s' "${content}" >"${output}"
}

mcp_url_encode() {
	local value="$1"
	if command -v python3 >/dev/null 2>&1; then
		PYTHONUTF8=1 python3 -c 'import sys, urllib.parse; print(urllib.parse.quote(sys.argv[1], safe=":/"))' "${value}"
		return 0
	fi
	local output=""
	local i
	local char
	local hex
	local LC_ALL=C
	for ((i = 0; i < ${#value}; i++)); do
		char="${value:i:1}"
		case "${char}" in
		[a-zA-Z0-9.~_-] | / | :)
			output+="${char}"
			;;
		*)
			printf -v hex '%02X' "'${char}"
			output+="%${hex}"
			;;
		esac
	done
	printf '%s' "${output}"
}

mcp_file_uri_from_path() {
	local path="$1"
	if command -v python3 >/dev/null 2>&1; then
		if PYTHONUTF8=1 python3 - "$path" <<'PY'; then
import pathlib, sys
print(pathlib.Path(sys.argv[1]).resolve().as_uri())
PY
			return 0
		fi
	fi
	local dir
	if ! dir="$(cd "$(dirname "${path}")" >/dev/null 2>&1 && pwd)"; then
		printf 'Unable to resolve resource path %s\n' "${path}" >&2
		return 1
	fi
	local base
	base="$(basename "${path}")"
	local abs_path="${dir}/${base}"
	mcp_url_encode "file://${abs_path}"
}

# Require MCPBASH_PROJECT_ROOT for scaffolding commands
mcp_scaffold_require_project_root() {
	if [ -z "${MCPBASH_PROJECT_ROOT:-}" ]; then
		cat >&2 <<'EOF'
mcp-bash scaffold: MCPBASH_PROJECT_ROOT is not set.

Scaffolding requires a project directory. Set MCPBASH_PROJECT_ROOT first:

  export MCPBASH_PROJECT_ROOT=/path/to/my-project
  mcp-bash scaffold tool my-tool

See: https://github.com/yaniv-golan/mcp-bash#quick-start
EOF
		exit 1
	fi

	if [ ! -d "${MCPBASH_PROJECT_ROOT}" ]; then
		printf 'mcp-bash scaffold: MCPBASH_PROJECT_ROOT directory does not exist: %s\n' "${MCPBASH_PROJECT_ROOT}" >&2
		printf 'Create it first: mkdir -p %s\n' "${MCPBASH_PROJECT_ROOT}" >&2
		exit 1
	fi
}

# Initialize paths for scaffolding (lighter than full runtime init)
initialize_scaffold_paths() {
	local script_dir=""
	script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
	MCPBASH_HOME="$(cd "${script_dir}/.." && pwd)"

	# Set content directory paths based on MCPBASH_PROJECT_ROOT
	if [ -z "${MCPBASH_TOOLS_DIR:-}" ]; then
		MCPBASH_TOOLS_DIR="${MCPBASH_PROJECT_ROOT}/tools"
	fi
	if [ -z "${MCPBASH_RESOURCES_DIR:-}" ]; then
		MCPBASH_RESOURCES_DIR="${MCPBASH_PROJECT_ROOT}/resources"
	fi
	if [ -z "${MCPBASH_PROMPTS_DIR:-}" ]; then
		MCPBASH_PROMPTS_DIR="${MCPBASH_PROJECT_ROOT}/prompts"
	fi
}

mcp_scaffold_tool() {
	local name="$1"
	if [ -z "${name}" ]; then
		printf 'Tool name required\n' >&2
		exit 1
	fi
	mcp_scaffold_require_project_root
	initialize_scaffold_paths
	local scaffold_dir="${MCPBASH_HOME}/scaffold/tool"
	if [ ! -d "${scaffold_dir}" ]; then
		printf 'Scaffold templates missing at %s\n' "${scaffold_dir}" >&2
		exit 1
	fi
	local target_dir="${MCPBASH_TOOLS_DIR}/${name}"
	if [ -e "${target_dir}" ]; then
		printf 'Target %s already exists\n' "${target_dir}" >&2
		exit 1
	fi
	mkdir -p "${target_dir}"
	mcp_template_render "${scaffold_dir}/tool.sh" "${target_dir}/${name}.sh" "__NAME__=${name}"
	chmod +x "${target_dir}/${name}.sh"
	mcp_template_render "${scaffold_dir}/tool.meta.json" "${target_dir}/${name}.meta.json" "__NAME__=${name}"
	mcp_template_render "${scaffold_dir}/README.md" "${target_dir}/README.md" "__NAME__=${name}"
	printf 'Scaffolded tool at %s\n' "${target_dir}"
	exit 0
}

mcp_scaffold_prompt() {
	local name="$1"
	if [ -z "${name}" ]; then
		printf 'Prompt name required\n' >&2
		exit 1
	fi
	mcp_scaffold_require_project_root
	initialize_scaffold_paths
	local scaffold_dir="${MCPBASH_HOME}/scaffold/prompt"
	if [ ! -d "${scaffold_dir}" ]; then
		printf 'Scaffold templates missing at %s\n' "${scaffold_dir}" >&2
		exit 1
	fi
	local target_dir="${MCPBASH_PROMPTS_DIR}/${name}"
	if [ -e "${target_dir}" ]; then
		printf 'Target %s already exists\n' "${target_dir}" >&2
		exit 1
	fi
	mkdir -p "${target_dir}"
	mcp_template_render "${scaffold_dir}/prompt.txt" "${target_dir}/${name}.txt" "__NAME__=${name}"
	mcp_template_render "${scaffold_dir}/prompt.meta.json" "${target_dir}/${name}.meta.json" "__NAME__=${name}"
	mcp_template_render "${scaffold_dir}/README.md" "${target_dir}/README.md" "__NAME__=${name}"
	printf 'Scaffolded prompt at %s\n' "${target_dir}"
	exit 0
}

mcp_scaffold_resource() {
	local name="$1"
	if [ -z "${name}" ]; then
		printf 'Resource name required\n' >&2
		exit 1
	fi
	mcp_scaffold_require_project_root
	initialize_scaffold_paths
	local scaffold_dir="${MCPBASH_HOME}/scaffold/resource"
	if [ ! -d "${scaffold_dir}" ]; then
		printf 'Scaffold templates missing at %s\n' "${scaffold_dir}" >&2
		exit 1
	fi
	local target_dir="${MCPBASH_RESOURCES_DIR}/${name}"
	if [ -e "${target_dir}" ]; then
		printf 'Target %s already exists\n' "${target_dir}" >&2
		exit 1
	fi
	mkdir -p "${target_dir}"
	mcp_template_render "${scaffold_dir}/resource.txt" "${target_dir}/${name}.txt" "__NAME__=${name}"
	local resource_abs_path="${target_dir}/${name}.txt"
	local resource_uri=""

	if [ -f "${resource_abs_path}" ]; then
		local dir base
		dir="$(dirname "${resource_abs_path}")"
		base="$(basename "${resource_abs_path}")"
		dir="$(cd "${dir}" >/dev/null 2>&1 && pwd)"
		resource_abs_path="${dir}/${base}"
	fi

	if ! resource_uri="$(mcp_file_uri_from_path "${resource_abs_path}")"; then
		printf 'Unable to build resource URI\n' >&2
		exit 1
	fi

	mcp_template_render "${scaffold_dir}/resource.meta.json" "${target_dir}/${name}.meta.json" "__NAME__=${name}" "__RESOURCE_URI__=${resource_uri}"
	mcp_template_render "${scaffold_dir}/README.md" "${target_dir}/README.md" "__NAME__=${name}"
	printf 'Scaffolded resource at %s\n' "${target_dir}"
	exit 0
}

# Keep a stable, versioned core separated from extension directories.
MCPBASH_SERVER_NAME="mcp-bash"
MCPBASH_SERVER_TITLE="MCP Bash Server"
MCPBASH_SERVER_VERSION="0.1.0"
MCPBASH_PROTOCOL_VERSION="2025-06-18"
MCPBASH_NEGOTIATED_PROTOCOL_VERSION="${MCPBASH_PROTOCOL_VERSION}"
MCPBASH_HOME=""

require_bash_runtime() {
	if [ -z "${BASH_VERSION-}" ]; then
		printf 'mcp-bash must be launched with Bash; current shell is incompatible.\n' >&2
		exit 1
	fi

	local major="${BASH_VERSINFO[0]}"
	local minor="${BASH_VERSINFO[1]}"

	if [ "${major}" -lt 3 ] || { [ "${major}" -eq 3 ] && [ "${minor}" -lt 2 ]; }; then
		printf 'mcp-bash requires Bash 3.2 or newer (detected %s).\n' "${BASH_VERSION}" >&2
		exit 1
	fi
}

# Establish project root and source runtime detection helpers.
initialize_runtime_paths() {
	local script_dir=""

	script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
	MCPBASH_HOME="$(cd "${script_dir}/.." && pwd)"

	local required_libs="runtime json hash ids lock io paginate logging spec tools resources prompts completion timeout rpc core"
	local lib

	for lib in ${required_libs}; do
		if [ ! -r "${MCPBASH_HOME}/lib/${lib}.sh" ]; then
			printf '%s\n' "Missing required library at ${MCPBASH_HOME}/lib/${lib}.sh (bootstrap prerequisites)." >&2
			exit 1
		fi
	done

	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/runtime.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/json.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/hash.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/ids.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/lock.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/io.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/paginate.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/logging.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/spec.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/tools.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/resources.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/prompts.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/completion.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/rpc.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/core.sh"
}

mcp_verify_stdout_target() {
	# Reject configurations where stdout is not connected to a pipe or terminal.
	if [ -t 1 ]; then
		return 0
	fi

	# macOS/Linux expose /dev/stdout as a character device even when piped; fall back to a write probe.
	if ! { : >&1; } 2>/dev/null; then
		printf '%s\n' 'mcp-bash requires stdout to be connected to an active pipe or terminal (stdout must be connected).' >&2
		exit 1
	fi
}

main() {
	require_bash_runtime
	initialize_runtime_paths
	mcp_verify_stdout_target
	mcp_runtime_detect_json_tool
	mcp_runtime_log_batch_mode

	trap 'mcp_runtime_cleanup' EXIT INT TERM

	if mcp_runtime_is_minimal_mode; then
		# Warn about reduced capability surface.
		printf '%s\n' 'Operating in minimal mode: only lifecycle, ping, and logging handlers are exposed until JSON tooling becomes available (JSON tooling needed).' >&2
	fi

	# Bootstrap: begin primary lifecycle loop.
	mcp_core_run
}

if [ "${1-}" = "scaffold" ]; then
	shift
	case "${1-}" in
	tool)
		shift
		mcp_scaffold_tool "${1:-}"
		;;
	prompt)
		shift
		mcp_scaffold_prompt "${1:-}"
		;;
	resource)
		shift
		mcp_scaffold_resource "${1:-}"
		;;
	*)
		usage
		exit 1
		;;
	esac
fi

main "$@"
