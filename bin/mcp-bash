#!/usr/bin/env bash
# mcp-bash must execute on Bash â‰¥3.2 across macOS/Linux/WSL without edits.
# Core targets MCP protocol version 2025-06-18 and maintains stdout discipline.
# Transport scope is limited to stdio; no alternative transports are supported.

set -euo pipefail

usage() {
	cat <<'EOF'
Usage:
  mcp-bash                 # launch server
  mcp-bash scaffold tool <name>
  mcp-bash scaffold prompt <name>
  mcp-bash scaffold resource <name>
  mcp-bash registry refresh [--project-root DIR] [--no-notify] [--quiet] [--filter PATH]
EOF
}

mcp_template_render() {
	local template="$1"
	local output="$2"
	shift 2
	local content
	content="$(cat "${template}")"
	for pair in "$@"; do
		local key="${pair%%=*}"
		local value="${pair#*=}"
		content="${content//${key}/${value}}"
	done
	printf '%s' "${content}" >"${output}"
}

mcp_url_encode() {
	local value="$1"
	if command -v python3 >/dev/null 2>&1; then
		PYTHONUTF8=1 python3 -c 'import sys, urllib.parse; print(urllib.parse.quote(sys.argv[1], safe=":/"))' "${value}"
		return 0
	fi
	local output=""
	local i
	local char
	local hex
	local LC_ALL=C
	for ((i = 0; i < ${#value}; i++)); do
		char="${value:i:1}"
		case "${char}" in
		[a-zA-Z0-9.~_-] | / | :)
			output+="${char}"
			;;
		*)
			printf -v hex '%02X' "'${char}"
			output+="%${hex}"
			;;
		esac
	done
	printf '%s' "${output}"
}

mcp_file_uri_from_path() {
	local path="$1"
	if command -v python3 >/dev/null 2>&1; then
		if PYTHONUTF8=1 python3 - "$path" <<'PY'; then
import pathlib, sys
print(pathlib.Path(sys.argv[1]).resolve().as_uri())
PY
			return 0
		fi
	fi
	local dir
	if ! dir="$(cd "$(dirname "${path}")" >/dev/null 2>&1 && pwd)"; then
		printf 'Unable to resolve resource path %s\n' "${path}" >&2
		return 1
	fi
	local base
	base="$(basename "${path}")"
	local abs_path="${dir}/${base}"
	mcp_url_encode "file://${abs_path}"
}

# Require MCPBASH_PROJECT_ROOT for scaffolding commands
mcp_scaffold_require_project_root() {
	if [ -z "${MCPBASH_PROJECT_ROOT:-}" ]; then
		cat >&2 <<'EOF'
mcp-bash scaffold: MCPBASH_PROJECT_ROOT is not set.

Scaffolding requires a project directory. Set MCPBASH_PROJECT_ROOT first:

  export MCPBASH_PROJECT_ROOT=/path/to/my-project
  mcp-bash scaffold tool my-tool

See: https://github.com/yaniv-golan/mcp-bash#quick-start
EOF
		exit 1
	fi

	if [ ! -d "${MCPBASH_PROJECT_ROOT}" ]; then
		printf 'mcp-bash scaffold: MCPBASH_PROJECT_ROOT directory does not exist: %s\n' "${MCPBASH_PROJECT_ROOT}" >&2
		printf 'Create it first: mkdir -p %s\n' "${MCPBASH_PROJECT_ROOT}" >&2
		exit 1
	fi
}

# Initialize paths for scaffolding (lighter than full runtime init)
initialize_scaffold_paths() {
	local script_dir=""
	script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
	MCPBASH_HOME="$(cd "${script_dir}/.." && pwd)"

	# Set content directory paths based on MCPBASH_PROJECT_ROOT
	if [ -z "${MCPBASH_TOOLS_DIR:-}" ]; then
		MCPBASH_TOOLS_DIR="${MCPBASH_PROJECT_ROOT}/tools"
	fi
	if [ -z "${MCPBASH_RESOURCES_DIR:-}" ]; then
		MCPBASH_RESOURCES_DIR="${MCPBASH_PROJECT_ROOT}/resources"
	fi
	if [ -z "${MCPBASH_PROMPTS_DIR:-}" ]; then
		MCPBASH_PROMPTS_DIR="${MCPBASH_PROJECT_ROOT}/prompts"
	fi
}

mcp_scaffold_tool() {
	local name="$1"
	if [ -z "${name}" ]; then
		printf 'Tool name required\n' >&2
		exit 1
	fi
	mcp_scaffold_require_project_root
	initialize_scaffold_paths
	local scaffold_dir="${MCPBASH_HOME}/scaffold/tool"
	if [ ! -d "${scaffold_dir}" ]; then
		printf 'Scaffold templates missing at %s\n' "${scaffold_dir}" >&2
		exit 1
	fi
	local target_dir="${MCPBASH_TOOLS_DIR}/${name}"
	if [ -e "${target_dir}" ]; then
		printf 'Target %s already exists\n' "${target_dir}" >&2
		exit 1
	fi
	mkdir -p "${target_dir}"
	mcp_template_render "${scaffold_dir}/tool.sh" "${target_dir}/tool.sh" "__NAME__=${name}"
	chmod +x "${target_dir}/tool.sh"
	mcp_template_render "${scaffold_dir}/tool.meta.json" "${target_dir}/tool.meta.json" "__NAME__=${name}"
	mcp_template_render "${scaffold_dir}/README.md" "${target_dir}/README.md" "__NAME__=${name}"
	printf 'Scaffolded tool at %s\n' "${target_dir}"
	exit 0
}

mcp_scaffold_prompt() {
	local name="$1"
	if [ -z "${name}" ]; then
		printf 'Prompt name required\n' >&2
		exit 1
	fi
	mcp_scaffold_require_project_root
	initialize_scaffold_paths
	local scaffold_dir="${MCPBASH_HOME}/scaffold/prompt"
	if [ ! -d "${scaffold_dir}" ]; then
		printf 'Scaffold templates missing at %s\n' "${scaffold_dir}" >&2
		exit 1
	fi
	local target_dir="${MCPBASH_PROMPTS_DIR}/${name}"
	if [ -e "${target_dir}" ]; then
		printf 'Target %s already exists\n' "${target_dir}" >&2
		exit 1
	fi
	mkdir -p "${target_dir}"
	mcp_template_render "${scaffold_dir}/prompt.txt" "${target_dir}/${name}.txt" "__NAME__=${name}"
	mcp_template_render "${scaffold_dir}/prompt.meta.json" "${target_dir}/${name}.meta.json" "__NAME__=${name}"
	mcp_template_render "${scaffold_dir}/README.md" "${target_dir}/README.md" "__NAME__=${name}"
	printf 'Scaffolded prompt at %s\n' "${target_dir}"
	exit 0
}

mcp_scaffold_resource() {
	local name="$1"
	if [ -z "${name}" ]; then
		printf 'Resource name required\n' >&2
		exit 1
	fi
	mcp_scaffold_require_project_root
	initialize_scaffold_paths
	local scaffold_dir="${MCPBASH_HOME}/scaffold/resource"
	if [ ! -d "${scaffold_dir}" ]; then
		printf 'Scaffold templates missing at %s\n' "${scaffold_dir}" >&2
		exit 1
	fi
	local target_dir="${MCPBASH_RESOURCES_DIR}/${name}"
	if [ -e "${target_dir}" ]; then
		printf 'Target %s already exists\n' "${target_dir}" >&2
		exit 1
	fi
	mkdir -p "${target_dir}"
	mcp_template_render "${scaffold_dir}/resource.txt" "${target_dir}/${name}.txt" "__NAME__=${name}"
	local resource_abs_path="${target_dir}/${name}.txt"
	local resource_uri=""

	if [ -f "${resource_abs_path}" ]; then
		local dir base
		dir="$(dirname "${resource_abs_path}")"
		base="$(basename "${resource_abs_path}")"
		dir="$(cd "${dir}" >/dev/null 2>&1 && pwd)"
		resource_abs_path="${dir}/${base}"
	fi

	if ! resource_uri="$(mcp_file_uri_from_path "${resource_abs_path}")"; then
		printf 'Unable to build resource URI\n' >&2
		exit 1
	fi

	mcp_template_render "${scaffold_dir}/resource.meta.json" "${target_dir}/${name}.meta.json" "__NAME__=${name}" "__RESOURCE_URI__=${resource_uri}"
	mcp_template_render "${scaffold_dir}/README.md" "${target_dir}/README.md" "__NAME__=${name}"
	printf 'Scaffolded resource at %s\n' "${target_dir}"
	exit 0
}

mcp_registry_refresh_cli() {
	local project_root=""
	local quiet="false"
	local no_notify="false"
	local filter_path=""

	while [ $# -gt 0 ]; do
		case "$1" in
		--project-root)
			shift
			project_root="${1:-}"
			;;
		--quiet)
			quiet="true"
			;;
		--no-notify)
			no_notify="true"
			;;
		--filter)
			shift
			filter_path="${1:-}"
			;;
		*)
			usage
			exit 1
			;;
		esac
		shift
	done

	if [ -n "${project_root}" ]; then
		MCPBASH_PROJECT_ROOT="${project_root%/}"
		export MCPBASH_PROJECT_ROOT
		no_notify="true" # implied by --project-root (offline mode)
	fi
	if [ -z "${MCPBASH_TMP_ROOT:-}" ]; then
		MCPBASH_TMP_ROOT="${TMPDIR:-/tmp}"
	fi
	if [ -z "${MCPBASH_LOCK_ROOT:-}" ]; then
		MCPBASH_LOCK_ROOT="${MCPBASH_TMP_ROOT%/}/mcpbash.locks"
	fi
	if [ -z "${MCPBASH_STATE_DIR:-}" ]; then
		MCPBASH_STATE_DIR="${MCPBASH_TMP_ROOT%/}/mcpbash.state.$$"
	fi
	if [ -z "${MCPBASH_REGISTRY_DIR:-}" ]; then
		MCPBASH_REGISTRY_DIR="${MCPBASH_PROJECT_ROOT%/}/.registry"
	fi
	if [ -z "${MCPBASH_TOOLS_DIR:-}" ]; then
		MCPBASH_TOOLS_DIR="${MCPBASH_PROJECT_ROOT%/}/tools"
	fi
	if [ -z "${MCPBASH_RESOURCES_DIR:-}" ]; then
		MCPBASH_RESOURCES_DIR="${MCPBASH_PROJECT_ROOT%/}/resources"
	fi
	if [ -z "${MCPBASH_PROMPTS_DIR:-}" ]; then
		MCPBASH_PROMPTS_DIR="${MCPBASH_PROJECT_ROOT%/}/prompts"
	fi
	export MCPBASH_PROJECT_ROOT MCPBASH_REGISTRY_DIR MCPBASH_TOOLS_DIR MCPBASH_RESOURCES_DIR MCPBASH_PROMPTS_DIR MCPBASH_TMP_ROOT MCPBASH_LOCK_ROOT MCPBASH_STATE_DIR
	mkdir -p "${MCPBASH_LOCK_ROOT}" "${MCPBASH_STATE_DIR}" "${MCPBASH_REGISTRY_DIR}" >/dev/null 2>&1 || true
	MCP_TOOLS_REGISTRY_PATH="${MCPBASH_REGISTRY_DIR}/tools.json"
	MCP_RESOURCES_REGISTRY_PATH="${MCPBASH_REGISTRY_DIR}/resources.json"
	MCP_PROMPTS_REGISTRY_PATH="${MCPBASH_REGISTRY_DIR}/prompts.json"
	if [ "${quiet}" = "true" ]; then
		MCPBASH_LOG_LEVEL="error"
		export MCPBASH_LOG_LEVEL
	fi
	if [ -n "${filter_path}" ]; then
		export MCPBASH_REGISTRY_REFRESH_PATH="${filter_path}"
	fi

	require_bash_runtime
	initialize_runtime_paths
	if [ -z "${MCPBASH_TMP_ROOT:-}" ]; then
		MCPBASH_TMP_ROOT="${TMPDIR:-/tmp}"
	fi
	if [ -z "${MCPBASH_LOCK_ROOT:-}" ]; then
		MCPBASH_LOCK_ROOT="${MCPBASH_TMP_ROOT%/}/mcpbash.locks"
	fi
	if [ -z "${MCPBASH_STATE_DIR:-}" ]; then
		MCPBASH_STATE_DIR="${MCPBASH_TMP_ROOT%/}/mcpbash.state.$$"
	fi
	mcp_lock_init
	mcp_runtime_detect_json_tool
	mcp_runtime_log_batch_mode

	if [ "${no_notify}" = "true" ]; then
		MCPBASH_REGISTRY_REFRESH_NO_NOTIFY="true"
		export MCPBASH_REGISTRY_REFRESH_NO_NOTIFY
	fi

	local mode="full"
	if mcp_runtime_is_minimal_mode; then
		mode="minimal"
	fi

	local tools_status="ok"
	local resources_status="ok"
	local prompts_status="ok"
	local tools_error=""
	local resources_error=""
	local prompts_error=""
	local fatal=0
	local any_fail=0

	if mcp_runtime_is_minimal_mode; then
		tools_status="skipped"
		resources_status="skipped"
		prompts_status="skipped"
		tools_error="minimal mode"
		resources_error="minimal mode"
		prompts_error="minimal mode"
	else
		MCP_TOOLS_LAST_SCAN=0
		MCP_RESOURCES_LAST_SCAN=0
		MCP_PROMPTS_LAST_SCAN=0

		mcp_tools_refresh_registry || {
			case "$?" in
			2) fatal=1 ;;
			*) any_fail=1 ;;
			esac
			tools_status="failed"
			tools_error="refresh failed"
		}
		mcp_resources_refresh_registry || {
			case "$?" in
			2) fatal=1 ;;
			*) any_fail=1 ;;
			esac
			resources_status="failed"
			resources_error="refresh failed"
		}
		mcp_prompts_refresh_registry || {
			case "$?" in
			2) fatal=1 ;;
			*) any_fail=1 ;;
			esac
			prompts_status="failed"
			prompts_error="refresh failed"
		}
	fi

	local tools_error_json resources_error_json prompts_error_json
	tools_error_json="null"
	resources_error_json="null"
	prompts_error_json="null"
	if [ -n "${tools_error}" ]; then
		tools_error_json="$(mcp_json_quote_text "${tools_error}")"
	fi
	if [ -n "${resources_error}" ]; then
		resources_error_json="$(mcp_json_quote_text "${resources_error}")"
	fi
	if [ -n "${prompts_error}" ]; then
		prompts_error_json="$(mcp_json_quote_text "${prompts_error}")"
	fi

	local json_output
	json_output="$(cat <<EOF
{
  "tools": {"status":"${tools_status}","count":${MCP_TOOLS_TOTAL:-0},"error":${tools_error_json}},
  "resources": {"status":"${resources_status}","count":${MCP_RESOURCES_TOTAL:-0},"error":${resources_error_json}},
  "prompts": {"status":"${prompts_status}","count":${MCP_PROMPTS_TOTAL:-0},"error":${prompts_error_json}},
  "notificationsSent": false,
  "mode": "${mode}"
}
EOF
)"

	printf '%s\n' "${json_output}"

	if [ "${fatal}" -eq 1 ]; then
		exit 2
	fi
	if [ "${any_fail}" -eq 1 ]; then
		exit 1
	fi
	exit 0
}

# Keep a stable, versioned core separated from extension directories.
MCPBASH_SERVER_NAME="mcp-bash"
MCPBASH_SERVER_TITLE="MCP Bash Server"
MCPBASH_SERVER_VERSION="0.1.0"
MCPBASH_PROTOCOL_VERSION="2025-06-18"
MCPBASH_NEGOTIATED_PROTOCOL_VERSION="${MCPBASH_PROTOCOL_VERSION}"
MCPBASH_HOME=""

require_bash_runtime() {
	if [ -z "${BASH_VERSION-}" ]; then
		printf 'mcp-bash must be launched with Bash; current shell is incompatible.\n' >&2
		exit 1
	fi

	local major="${BASH_VERSINFO[0]}"
	local minor="${BASH_VERSINFO[1]}"

	if [ "${major}" -lt 3 ] || { [ "${major}" -eq 3 ] && [ "${minor}" -lt 2 ]; }; then
		printf 'mcp-bash requires Bash 3.2 or newer (detected %s).\n' "${BASH_VERSION}" >&2
		exit 1
	fi
}

# Establish project root and source runtime detection helpers.
initialize_runtime_paths() {
	local script_dir=""

	script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
	MCPBASH_HOME="$(cd "${script_dir}/.." && pwd)"

	local required_libs="runtime json hash ids lock io paginate logging registry spec tools resources prompts completion timeout rpc core"
	local lib

	for lib in ${required_libs}; do
		if [ ! -r "${MCPBASH_HOME}/lib/${lib}.sh" ]; then
			printf '%s\n' "Missing required library at ${MCPBASH_HOME}/lib/${lib}.sh (bootstrap prerequisites)." >&2
			exit 1
		fi
	done

	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/runtime.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/json.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/hash.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/ids.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/lock.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/io.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/paginate.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/logging.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/registry.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/spec.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/tools.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/resources.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/prompts.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/completion.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/rpc.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/core.sh"
}

mcp_verify_stdout_target() {
	# Reject configurations where stdout is not connected to a pipe or terminal.
	if [ -t 1 ]; then
		return 0
	fi

	# macOS/Linux expose /dev/stdout as a character device even when piped; fall back to a write probe.
	if ! { : >&1; } 2>/dev/null; then
		printf '%s\n' 'mcp-bash requires stdout to be connected to an active pipe or terminal (stdout must be connected).' >&2
		exit 1
	fi
}

main() {
	require_bash_runtime
	initialize_runtime_paths
	mcp_verify_stdout_target
	mcp_runtime_detect_json_tool
	mcp_runtime_log_batch_mode

	trap 'mcp_runtime_cleanup' EXIT INT TERM

	if mcp_runtime_is_minimal_mode; then
		# Warn about reduced capability surface.
		printf '%s\n' 'Operating in minimal mode: only lifecycle, ping, and logging handlers are exposed until JSON tooling becomes available (JSON tooling needed).' >&2
	fi

	# Bootstrap: begin primary lifecycle loop.
	mcp_core_run
}

if [ "${1-}" = "registry" ]; then
	shift
	case "${1-}" in
	refresh)
		shift
		mcp_registry_refresh_cli "$@"
		;;
	*)
		usage
		exit 1
		;;
	esac
fi

if [ "${1-}" = "scaffold" ]; then
	shift
	case "${1-}" in
	tool)
		shift
		mcp_scaffold_tool "${1:-}"
		;;
	prompt)
		shift
		mcp_scaffold_prompt "${1:-}"
		;;
	resource)
		shift
		mcp_scaffold_resource "${1:-}"
		;;
	*)
		usage
		exit 1
		;;
	esac
fi

main "$@"
