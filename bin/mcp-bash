#!/usr/bin/env bash
# mcp-bash must execute on Bash â‰¥3.2 across macOS/Linux/WSL without edits.
# Core targets MCP protocol version 2025-06-18 and maintains stdout discipline.
# Transport scope is limited to stdio; no alternative transports are supported.

set -euo pipefail

usage() {
	cat <<'EOF'
Usage:
  mcp-bash                 # launch server
  mcp-bash --help          # show this help
  mcp-bash --version       # show version
  mcp-bash debug           # launch server with debug logging (see docs/DEBUGGING.md)
  mcp-bash scaffold tool <name>
  mcp-bash scaffold prompt <name>
  mcp-bash scaffold resource <name>
  mcp-bash registry refresh [--project-root DIR] [--no-notify] [--quiet] [--filter PATH]

Note: running without MCPBASH_PROJECT_ROOT starts a temporary getting-started helper tool.
EOF
}

mcp_template_render() {
	local template="$1"
	local output="$2"
	shift 2
	local content
	content="$(cat "${template}")"
	for pair in "$@"; do
		local key="${pair%%=*}"
		local value="${pair#*=}"
		content="${content//${key}/${value}}"
	done
	printf '%s' "${content}" >"${output}"
}

mcp_load_uri_helpers() {
	if declare -F mcp_uri_file_uri_from_path >/dev/null 2>&1; then
		return 0
	fi
	local script_dir
	script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
	# shellcheck disable=SC1090
	. "${script_dir}/../lib/uri.sh"
}

mcp_file_uri_from_path() {
	mcp_load_uri_helpers
	mcp_uri_file_uri_from_path "$1"
}

# Require MCPBASH_PROJECT_ROOT for scaffolding commands
mcp_scaffold_require_project_root() {
	if [ -z "${MCPBASH_PROJECT_ROOT:-}" ]; then
		cat >&2 <<'EOF'
mcp-bash scaffold: MCPBASH_PROJECT_ROOT is not set.

Scaffolding requires a project directory. Set MCPBASH_PROJECT_ROOT first:

  export MCPBASH_PROJECT_ROOT=/path/to/my-project
  mcp-bash scaffold tool my-tool

See: https://github.com/yaniv-golan/mcp-bash-framework#quick-start
EOF
		exit 1
	fi

	if [ ! -d "${MCPBASH_PROJECT_ROOT}" ]; then
		printf 'mcp-bash scaffold: MCPBASH_PROJECT_ROOT directory does not exist: %s\n' "${MCPBASH_PROJECT_ROOT}" >&2
		printf 'Create it first: mkdir -p %s\n' "${MCPBASH_PROJECT_ROOT}" >&2
		exit 1
	fi
}

# Initialize paths for scaffolding (lighter than full runtime init)
initialize_scaffold_paths() {
	local script_dir=""
	script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
	MCPBASH_HOME="$(cd "${script_dir}/.." && pwd)"

	# Set content directory paths based on MCPBASH_PROJECT_ROOT
	if [ -z "${MCPBASH_TOOLS_DIR:-}" ]; then
		MCPBASH_TOOLS_DIR="${MCPBASH_PROJECT_ROOT}/tools"
	fi
	if [ -z "${MCPBASH_RESOURCES_DIR:-}" ]; then
		MCPBASH_RESOURCES_DIR="${MCPBASH_PROJECT_ROOT}/resources"
	fi
	if [ -z "${MCPBASH_PROMPTS_DIR:-}" ]; then
		MCPBASH_PROMPTS_DIR="${MCPBASH_PROJECT_ROOT}/prompts"
	fi
}

mcp_scaffold_tool() {
	local name="$1"
	if [ -z "${name}" ]; then
		printf 'Tool name required\n' >&2
		exit 1
	fi
	mcp_scaffold_require_project_root
	initialize_scaffold_paths
	local scaffold_dir="${MCPBASH_HOME}/scaffold/tool"
	if [ ! -d "${scaffold_dir}" ]; then
		printf 'Scaffold templates missing at %s\n' "${scaffold_dir}" >&2
		exit 1
	fi
	local target_dir="${MCPBASH_TOOLS_DIR}/${name}"
	if [ -e "${target_dir}" ]; then
		printf 'Target %s already exists (remove it or choose a new tool name)\n' "${target_dir}" >&2
		exit 1
	fi
	mkdir -p "${target_dir}"
	mcp_template_render "${scaffold_dir}/tool.sh" "${target_dir}/tool.sh" "__NAME__=${name}"
	chmod +x "${target_dir}/tool.sh"
	mcp_template_render "${scaffold_dir}/tool.meta.json" "${target_dir}/tool.meta.json" "__NAME__=${name}"
	mcp_template_render "${scaffold_dir}/README.md" "${target_dir}/README.md" "__NAME__=${name}"
	printf 'Scaffolded tool at %s\n' "${target_dir}"
	exit 0
}

mcp_scaffold_prompt() {
	local name="$1"
	if [ -z "${name}" ]; then
		printf 'Prompt name required\n' >&2
		exit 1
	fi
	mcp_scaffold_require_project_root
	initialize_scaffold_paths
	local scaffold_dir="${MCPBASH_HOME}/scaffold/prompt"
	if [ ! -d "${scaffold_dir}" ]; then
		printf 'Scaffold templates missing at %s\n' "${scaffold_dir}" >&2
		exit 1
	fi
	local target_dir="${MCPBASH_PROMPTS_DIR}/${name}"
	if [ -e "${target_dir}" ]; then
		printf 'Target %s already exists (remove it or choose a new prompt name)\n' "${target_dir}" >&2
		exit 1
	fi
	mkdir -p "${target_dir}"
	mcp_template_render "${scaffold_dir}/prompt.txt" "${target_dir}/${name}.txt" "__NAME__=${name}"
	mcp_template_render "${scaffold_dir}/prompt.meta.json" "${target_dir}/${name}.meta.json" "__NAME__=${name}"
	mcp_template_render "${scaffold_dir}/README.md" "${target_dir}/README.md" "__NAME__=${name}"
	printf 'Scaffolded prompt at %s\n' "${target_dir}"
	exit 0
}

mcp_scaffold_resource() {
	local name="$1"
	if [ -z "${name}" ]; then
		printf 'Resource name required\n' >&2
		exit 1
	fi
	mcp_scaffold_require_project_root
	initialize_scaffold_paths
	local scaffold_dir="${MCPBASH_HOME}/scaffold/resource"
	if [ ! -d "${scaffold_dir}" ]; then
		printf 'Scaffold templates missing at %s\n' "${scaffold_dir}" >&2
		exit 1
	fi
	local target_dir="${MCPBASH_RESOURCES_DIR}/${name}"
	if [ -e "${target_dir}" ]; then
		printf 'Target %s already exists (remove it or choose a new resource name)\n' "${target_dir}" >&2
		exit 1
	fi
	mkdir -p "${target_dir}"
	local resource_path="${target_dir}/${name}.txt"
	local resource_uri
	if ! resource_uri="$(mcp_file_uri_from_path "${resource_path}")"; then
		printf 'Unable to compute resource URI for %s\n' "${resource_path}" >&2
		exit 1
	fi
	mcp_template_render "${scaffold_dir}/resource.txt" "${resource_path}" "__NAME__=${name}"
	mcp_template_render "${scaffold_dir}/resource.meta.json" "${target_dir}/${name}.meta.json" "__NAME__=${name}" "__RESOURCE_URI__=${resource_uri}"
	mcp_template_render "${scaffold_dir}/README.md" "${target_dir}/README.md" "__NAME__=${name}"
	printf 'Scaffolded resource at %s\n' "${target_dir}"
	exit 0
}

mcp_registry_refresh_cli() {
	local project_root=""
	local quiet="false"
	local no_notify="false"
	local filter_path=""

	while [ $# -gt 0 ]; do
		case "$1" in
		--project-root)
			shift
			project_root="${1:-}"
			;;
		--quiet)
			quiet="true"
			;;
		--no-notify)
			no_notify="true"
			;;
		--filter)
			shift
			filter_path="${1:-}"
			;;
		*)
			usage
			exit 1
			;;
		esac
		shift
	done

	# Set PROJECT_ROOT before library load
	if [ -n "${project_root}" ]; then
		MCPBASH_PROJECT_ROOT="${project_root}"
		export MCPBASH_PROJECT_ROOT
		no_notify="true" # implied by --project-root (offline mode)
	fi

	# Quiet mode (set before library load for logging)
	if [ "${quiet}" = "true" ]; then
		MCPBASH_LOG_LEVEL="error"
		MCPBASH_QUIET="true"
		export MCPBASH_LOG_LEVEL MCPBASH_QUIET
	fi

	# Filter path
	if [ -n "${filter_path}" ]; then
		export MCPBASH_REGISTRY_REFRESH_PATH="${filter_path}"
	fi

	# Load libraries and init paths with CLI mode
	require_bash_runtime
	initialize_runtime_paths
	mcp_runtime_init_paths "cli"
	mcp_lock_init
	mcp_runtime_detect_json_tool
	mcp_runtime_log_batch_mode

	if [ "${no_notify}" = "true" ]; then
		MCPBASH_REGISTRY_REFRESH_NO_NOTIFY="true"
		export MCPBASH_REGISTRY_REFRESH_NO_NOTIFY
	fi

	local mode="full"
	if mcp_runtime_is_minimal_mode; then
		mode="minimal"
	fi

	local tools_status="ok"
	local resources_status="ok"
	local prompts_status="ok"
	local tools_error=""
	local resources_error=""
	local prompts_error=""
	local fatal=0
	local any_fail=0

	if mcp_runtime_is_minimal_mode; then
		tools_status="skipped"
		resources_status="skipped"
		prompts_status="skipped"
		tools_error="minimal mode"
		resources_error="minimal mode"
		prompts_error="minimal mode"
	else
		MCP_TOOLS_LAST_SCAN=0
		MCP_RESOURCES_LAST_SCAN=0
		MCP_PROMPTS_LAST_SCAN=0

		mcp_tools_refresh_registry || {
			case "$?" in
			2) fatal=1 ;;
			*) any_fail=1 ;;
			esac
			tools_status="failed"
			tools_error="refresh failed"
		}
		mcp_resources_refresh_registry || {
			case "$?" in
			2) fatal=1 ;;
			*) any_fail=1 ;;
			esac
			resources_status="failed"
			resources_error="refresh failed"
		}
		mcp_prompts_refresh_registry || {
			case "$?" in
			2) fatal=1 ;;
			*) any_fail=1 ;;
			esac
			prompts_status="failed"
			prompts_error="refresh failed"
		}
	fi

	local tools_error_json resources_error_json prompts_error_json
	tools_error_json="null"
	resources_error_json="null"
	prompts_error_json="null"
	if [ -n "${tools_error}" ]; then
		tools_error_json="$(mcp_json_quote_text "${tools_error}")"
	fi
	if [ -n "${resources_error}" ]; then
		resources_error_json="$(mcp_json_quote_text "${resources_error}")"
	fi
	if [ -n "${prompts_error}" ]; then
		prompts_error_json="$(mcp_json_quote_text "${prompts_error}")"
	fi

	local json_output
	json_output="$(cat <<EOF
{
  "tools": {"status":"${tools_status}","count":${MCP_TOOLS_TOTAL:-0},"error":${tools_error_json}},
  "resources": {"status":"${resources_status}","count":${MCP_RESOURCES_TOTAL:-0},"error":${resources_error_json}},
  "prompts": {"status":"${prompts_status}","count":${MCP_PROMPTS_TOTAL:-0},"error":${prompts_error_json}},
  "notificationsSent": false,
  "mode": "${mode}"
}
EOF
)"

	printf '%s\n' "${json_output}"

	if [ "${fatal}" -eq 1 ]; then
		exit 2
	fi
	if [ "${any_fail}" -eq 1 ]; then
		exit 1
	fi
	exit 0
}

# Keep a stable, versioned core separated from extension directories.
# Server metadata (name, version, title, etc.) is loaded from server.d/server.meta.json
# with smart defaults derived from the project structure. See mcp_runtime_load_server_meta().
MCPBASH_PROTOCOL_VERSION="2025-06-18"
MCPBASH_NEGOTIATED_PROTOCOL_VERSION="${MCPBASH_PROTOCOL_VERSION}"
MCPBASH_HOME=""

require_bash_runtime() {
	if [ -z "${BASH_VERSION-}" ]; then
		printf 'mcp-bash must be launched with Bash; current shell is incompatible.\n' >&2
		exit 1
	fi

	local major="${BASH_VERSINFO[0]}"
	local minor="${BASH_VERSINFO[1]}"

	if [ "${major}" -lt 3 ] || { [ "${major}" -eq 3 ] && [ "${minor}" -lt 2 ]; }; then
		printf 'mcp-bash requires Bash 3.2 or newer (detected %s).\n' "${BASH_VERSION}" >&2
		exit 1
	fi
}

# Establish project root and source runtime detection helpers.
initialize_runtime_paths() {
	local script_dir=""

	script_dir="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
	MCPBASH_HOME="$(cd "${script_dir}/.." && pwd)"

	local required_libs="runtime json hash ids lock io paginate logging uri registry spec tools resources prompts completion timeout rpc core"
	local lib

	for lib in ${required_libs}; do
		if [ ! -r "${MCPBASH_HOME}/lib/${lib}.sh" ]; then
			printf '%s\n' "Missing required library at ${MCPBASH_HOME}/lib/${lib}.sh (bootstrap prerequisites)." >&2
			exit 1
		fi
	done

	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/runtime.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/json.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/hash.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/ids.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/lock.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/io.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/paginate.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/logging.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/uri.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/registry.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/spec.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/tools.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/resources.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/prompts.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/completion.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/timeout.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/elicitation.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/roots.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/rpc.sh"
	# shellcheck disable=SC1090
	. "${MCPBASH_HOME}/lib/core.sh"
}

mcp_verify_stdout_target() {
	# Reject configurations where stdout is not connected to a pipe or terminal.
	if [ -t 1 ]; then
		return 0
	fi

	# macOS/Linux expose /dev/stdout as a character device even when piped; fall back to a write probe.
	if ! { : >&1; } 2>/dev/null; then
		printf '%s\n' 'mcp-bash requires stdout to be connected to an active pipe or terminal (stdout must be connected).' >&2
		exit 1
	fi
}

main() {
	require_bash_runtime
	initialize_runtime_paths
	mcp_verify_stdout_target
	mcp_runtime_detect_json_tool
	mcp_runtime_log_batch_mode

	trap 'mcp_runtime_cleanup' EXIT INT TERM HUP

	if mcp_runtime_is_minimal_mode; then
		# Warn about reduced capability surface.
		printf '%s\n' 'Operating in minimal mode: only lifecycle, ping, and logging handlers are exposed until JSON tooling becomes available (JSON tooling needed).' >&2
	fi

	# Bootstrap: begin primary lifecycle loop.
	mcp_core_run
}

case "${1-}" in
--help | -h)
	usage
	exit 0
	;;
--version | -v)
	# Read framework version from VERSION file
	_version_file="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)/VERSION"
	if [ -f "${_version_file}" ]; then
		printf 'mcp-bash %s\n' "$(tr -d '[:space:]' <"${_version_file}")"
	else
		printf 'mcp-bash (unknown version)\n'
	fi
	exit 0
	;;
esac

if [ "${1-}" = "registry" ]; then
	shift
	case "${1-}" in
	refresh)
		shift
		mcp_registry_refresh_cli "$@"
		;;
	*)
		usage
		exit 1
		;;
	esac
fi

if [ "${1-}" = "scaffold" ]; then
	shift
	case "${1-}" in
	tool)
		shift
		mcp_scaffold_tool "${1:-}"
		;;
	prompt)
		shift
		mcp_scaffold_prompt "${1:-}"
		;;
	resource)
		shift
		mcp_scaffold_resource "${1:-}"
		;;
	*)
		usage
		exit 1
		;;
	esac
fi

if [ "${1-}" = "debug" ]; then
	shift
	export MCPBASH_DEBUG_PAYLOADS=true
	export MCPBASH_PRESERVE_STATE=true
	# Create predictable debug directory
	MCPBASH_STATE_DIR="${TMPDIR:-/tmp}/mcpbash.debug.$$"
	export MCPBASH_STATE_DIR
	mkdir -p "${MCPBASH_STATE_DIR}"
	# Print location to stderr immediately (safe for stdio servers)
	printf 'mcp-bash debug: logging to %s/payload.debug.log\n' "${MCPBASH_STATE_DIR}" >&2
	main "$@"
	exit $?
fi

main "$@"
